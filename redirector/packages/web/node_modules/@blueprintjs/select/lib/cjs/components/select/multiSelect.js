"use strict";
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the terms of the LICENSE file distributed with this project.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var React = tslib_1.__importStar(require("react"));
var core_1 = require("@blueprintjs/core");
var common_1 = require("../../common");
var queryList_1 = require("../query-list/queryList");
var MultiSelect = /** @class */ (function (_super) {
    tslib_1.__extends(MultiSelect, _super);
    function MultiSelect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            isOpen: false,
            query: "",
        };
        _this.TypedQueryList = queryList_1.QueryList.ofType();
        _this.refHandlers = {
            input: function (ref) {
                _this.input = ref;
                var _a = _this.props.tagInputProps, tagInputProps = _a === void 0 ? {} : _a;
                core_1.Utils.safeInvoke(tagInputProps.inputRef, ref);
            },
            queryList: function (ref) { return (_this.queryList = ref); },
        };
        _this.renderQueryList = function (listProps) {
            var _a = _this.props, _b = _a.tagInputProps, tagInputProps = _b === void 0 ? {} : _b, _c = _a.popoverProps, popoverProps = _c === void 0 ? {} : _c, _d = _a.selectedItems, selectedItems = _d === void 0 ? [] : _d;
            var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp, query = listProps.query;
            var defaultInputProps = tslib_1.__assign({ placeholder: "Search..." }, tagInputProps.inputProps, { onChange: _this.handleQueryChange, value: query });
            return (React.createElement(core_1.Popover, tslib_1.__assign({ autoFocus: false, canEscapeKeyClose: true, enforceFocus: false, isOpen: _this.state.isOpen, position: core_1.Position.BOTTOM_LEFT }, popoverProps, { className: classnames_1.default(listProps.className, popoverProps.className), onInteraction: _this.handlePopoverInteraction, popoverClassName: classnames_1.default(common_1.Classes.MULTISELECT_POPOVER, popoverProps.popoverClassName), popoverDidOpen: _this.handlePopoverDidOpen, popoverWillOpen: _this.handlePopoverWillOpen }),
                React.createElement("div", { onKeyDown: _this.getTargetKeyDownHandler(handleKeyDown), onKeyUp: _this.state.isOpen ? handleKeyUp : undefined },
                    React.createElement(core_1.TagInput, tslib_1.__assign({}, tagInputProps, { inputProps: defaultInputProps, inputRef: _this.refHandlers.input, className: classnames_1.default(common_1.Classes.MULTISELECT, tagInputProps.className), values: selectedItems.map(_this.props.tagRenderer) }))),
                React.createElement("div", { onKeyDown: _this.getTargetKeyDownHandler(handleKeyDown), onKeyUp: handleKeyUp }, listProps.itemList)));
        };
        _this.isQueryEmpty = function () { return _this.state.query.length === 0; };
        _this.handleQueryChange = function (evt) {
            var _a = _this.props, _b = _a.tagInputProps, tagInputProps = _b === void 0 ? {} : _b, openOnKeyDown = _a.openOnKeyDown;
            var query = evt.currentTarget.value;
            _this.setState({ query: query, isOpen: !_this.isQueryEmpty() || !openOnKeyDown });
            if (tagInputProps.inputProps != null) {
                core_1.Utils.safeInvoke(tagInputProps.inputProps.onChange, evt);
            }
        };
        _this.handleItemSelect = function (item, evt) {
            if (_this.input != null) {
                _this.input.focus();
            }
            // make sure the query is valid by checking if activeItem is defined
            if (_this.state.activeItem != null) {
                if (_this.props.resetOnSelect && !_this.isQueryEmpty()) {
                    _this.setState({
                        activeItem: _this.props.items[0],
                        query: "",
                    });
                }
                core_1.Utils.safeInvoke(_this.props.onItemSelect, item, evt);
            }
        };
        _this.handlePopoverInteraction = function (nextOpenState) {
            return requestAnimationFrame(function () {
                // deferring to rAF to get properly updated activeElement
                var _a = _this.props, _b = _a.popoverProps, popoverProps = _b === void 0 ? {} : _b, resetOnSelect = _a.resetOnSelect;
                if (_this.input != null && _this.input !== document.activeElement) {
                    // the input is no longer focused so we can close the popover
                    _this.setState({
                        activeItem: resetOnSelect ? _this.props.items[0] : _this.state.activeItem,
                        isOpen: false,
                        query: resetOnSelect ? "" : _this.state.query,
                    });
                }
                else if (!_this.props.openOnKeyDown) {
                    // open the popover when focusing the tag input
                    _this.setState({ isOpen: true });
                }
                core_1.Utils.safeInvoke(popoverProps.onInteraction, nextOpenState);
            });
        };
        _this.handlePopoverWillOpen = function () {
            var _a = _this.props, _b = _a.popoverProps, popoverProps = _b === void 0 ? {} : _b, resetOnSelect = _a.resetOnSelect;
            if (resetOnSelect) {
                _this.setState({ activeItem: _this.props.items[0] });
            }
            core_1.Utils.safeInvoke(popoverProps.popoverWillOpen);
        };
        _this.handlePopoverDidOpen = function () {
            var _a = _this.props.popoverProps, popoverProps = _a === void 0 ? {} : _a;
            if (_this.queryList != null) {
                // scroll active item into view after popover transition completes and all dimensions are stable.
                _this.queryList.scrollActiveItemIntoView();
            }
            core_1.Utils.safeInvoke(popoverProps.popoverDidOpen);
        };
        _this.handleActiveItemChange = function (activeItem) { return _this.setState({ activeItem: activeItem }); };
        _this.getTargetKeyDownHandler = function (handleQueryListKeyDown) {
            return function (e) {
                var which = e.which;
                var resetOnSelect = _this.props.resetOnSelect;
                if (which === core_1.Keys.ESCAPE || which === core_1.Keys.TAB) {
                    // By default the escape key will not trigger a blur on the
                    // input element. It must be done explicitly.
                    if (_this.input != null) {
                        _this.input.blur();
                    }
                    _this.setState({
                        activeItem: resetOnSelect ? _this.props.items[0] : _this.state.activeItem,
                        isOpen: false,
                        query: resetOnSelect ? "" : _this.state.query,
                    });
                }
                else if (!(which === core_1.Keys.BACKSPACE || which === core_1.Keys.ARROW_LEFT || which === core_1.Keys.ARROW_RIGHT)) {
                    _this.setState({ isOpen: true });
                }
                if (_this.state.isOpen) {
                    core_1.Utils.safeInvoke(handleQueryListKeyDown, e);
                }
            };
        };
        return _this;
    }
    MultiSelect.ofType = function () {
        return MultiSelect;
    };
    MultiSelect.prototype.render = function () {
        // omit props specific to this component, spread the rest.
        var _a = this.props, openOnKeyDown = _a.openOnKeyDown, popoverProps = _a.popoverProps, resetOnSelect = _a.resetOnSelect, tagInputProps = _a.tagInputProps, restProps = tslib_1.__rest(_a, ["openOnKeyDown", "popoverProps", "resetOnSelect", "tagInputProps"]);
        return (React.createElement(this.TypedQueryList, tslib_1.__assign({}, restProps, { activeItem: this.state.activeItem, onActiveItemChange: this.handleActiveItemChange, onItemSelect: this.handleItemSelect, query: this.state.query, ref: this.refHandlers.queryList, renderer: this.renderQueryList })));
    };
    MultiSelect.displayName = "Blueprint2.MultiSelect";
    return MultiSelect;
}(React.PureComponent));
exports.MultiSelect = MultiSelect;
