/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the terms of the LICENSE file distributed with this project.
 */
import * as tslib_1 from "tslib";
import classNames from "classnames";
import * as React from "react";
import { InputGroup, Keys, Popover, Position, Utils, } from "@blueprintjs/core";
import { Classes } from "../../common";
import { QueryList } from "../query-list/queryList";
var Suggest = /** @class */ (function (_super) {
    tslib_1.__extends(Suggest, _super);
    function Suggest() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            isOpen: false,
            isTyping: false,
            query: "",
        };
        _this.TypedQueryList = QueryList.ofType();
        _this.refHandlers = {
            input: function (ref) {
                _this.input = ref;
                var _a = _this.props.inputProps, inputProps = _a === void 0 ? {} : _a;
                Utils.safeInvoke(inputProps.inputRef, ref);
            },
            queryList: function (ref) { return (_this.queryList = ref); },
        };
        _this.renderQueryList = function (listProps) {
            var _a = _this.props, inputValueRenderer = _a.inputValueRenderer, _b = _a.inputProps, inputProps = _b === void 0 ? {} : _b, _c = _a.popoverProps, popoverProps = _c === void 0 ? {} : _c;
            var _d = _this.state, isTyping = _d.isTyping, selectedItem = _d.selectedItem, query = _d.query;
            var handleKeyDown = listProps.handleKeyDown, handleKeyUp = listProps.handleKeyUp;
            var inputValue = isTyping ? query : selectedItem ? inputValueRenderer(selectedItem) : "";
            return (React.createElement(Popover, tslib_1.__assign({ autoFocus: false, enforceFocus: false, isOpen: _this.state.isOpen, position: Position.BOTTOM_LEFT }, popoverProps, { className: classNames(listProps.className, popoverProps.className), onInteraction: _this.handlePopoverInteraction, popoverClassName: classNames(Classes.SELECT_POPOVER, popoverProps.popoverClassName), popoverDidOpen: _this.handlePopoverDidOpen, popoverWillClose: _this.handlePopoverWillClose }),
                React.createElement(InputGroup, tslib_1.__assign({ placeholder: "Search...", value: inputValue }, inputProps, { inputRef: _this.refHandlers.input, onChange: _this.handleQueryChange, onFocus: _this.handleInputFocus, onKeyDown: _this.getTargetKeyDownHandler(handleKeyDown), onKeyUp: _this.getTargetKeyUpHandler(handleKeyUp) })),
                React.createElement("div", { onKeyDown: handleKeyDown, onKeyUp: handleKeyUp }, listProps.itemList)));
        };
        _this.selectText = function () {
            // wait until the input is properly focused to select the text inside of it
            requestAnimationFrame(function () {
                if (_this.input != null) {
                    _this.input.setSelectionRange(0, _this.input.value.length);
                }
            });
        };
        _this.handleInputFocus = function (event) {
            var _a = _this.props, openOnKeyDown = _a.openOnKeyDown, _b = _a.inputProps, inputProps = _b === void 0 ? {} : _b;
            _this.selectText();
            if (!openOnKeyDown) {
                _this.setState({ isOpen: true });
            }
            Utils.safeInvoke(inputProps.onFocus, event);
        };
        _this.handleActiveItemChange = function (activeItem) { return _this.setState({ activeItem: activeItem }); };
        _this.handleItemSelect = function (item, event) {
            var nextOpenState;
            if (!_this.props.closeOnSelect) {
                if (_this.input != null) {
                    _this.input.focus();
                }
                _this.selectText();
                nextOpenState = true;
            }
            else {
                if (_this.input != null) {
                    _this.input.blur();
                }
                nextOpenState = false;
            }
            _this.setState({
                isOpen: nextOpenState,
                isTyping: false,
                query: "",
                selectedItem: item,
            });
            Utils.safeInvoke(_this.props.onItemSelect, item, event);
        };
        _this.handlePopoverInteraction = function (nextOpenState) {
            return requestAnimationFrame(function () {
                var _a = _this.props.popoverProps, popoverProps = _a === void 0 ? {} : _a;
                if (_this.input != null && _this.input !== document.activeElement) {
                    // the input is no longer focused so we can close the popover
                    _this.setState({ isOpen: false });
                }
                Utils.safeInvoke(popoverProps.onInteraction, nextOpenState);
            });
        };
        _this.handlePopoverDidOpen = function () {
            var _a = _this.props.popoverProps, popoverProps = _a === void 0 ? {} : _a;
            // scroll active item into view after popover transition completes and all dimensions are stable.
            if (_this.queryList != null) {
                _this.queryList.scrollActiveItemIntoView();
            }
            Utils.safeInvoke(popoverProps.popoverDidOpen);
        };
        _this.handlePopoverWillClose = function () {
            var _a = _this.props.popoverProps, popoverProps = _a === void 0 ? {} : _a;
            var selectedItem = _this.state.selectedItem;
            // reset the query when the popover close, make sure that the list
            // isn't filtered on when the popover opens next
            _this.setState({
                activeItem: selectedItem ? selectedItem : _this.props.items[0],
                query: "",
            });
            Utils.safeInvoke(popoverProps.popoverDidOpen);
        };
        _this.handleQueryChange = function (event) {
            var _a = _this.props.inputProps, inputProps = _a === void 0 ? {} : _a;
            _this.setState({
                isTyping: true,
                query: event.currentTarget.value,
            });
            Utils.safeInvoke(inputProps.onChange, event);
        };
        _this.getTargetKeyDownHandler = function (handleQueryListKeyDown) {
            return function (evt) {
                var which = evt.which;
                var _a = _this.state, isTyping = _a.isTyping, selectedItem = _a.selectedItem;
                var _b = _this.props, _c = _b.inputProps, inputProps = _c === void 0 ? {} : _c, openOnKeyDown = _b.openOnKeyDown;
                if (which === Keys.ESCAPE || which === Keys.TAB) {
                    if (_this.input != null) {
                        _this.input.blur();
                    }
                    _this.setState({
                        isOpen: false,
                        selectedItem: isTyping ? undefined : selectedItem,
                    });
                }
                else if (openOnKeyDown &&
                    which !== Keys.BACKSPACE &&
                    which !== Keys.ARROW_LEFT &&
                    which !== Keys.ARROW_RIGHT) {
                    _this.setState({ isOpen: true });
                }
                if (_this.state.isOpen) {
                    Utils.safeInvoke(handleQueryListKeyDown, evt);
                }
                Utils.safeInvoke(inputProps.onKeyDown, evt);
            };
        };
        _this.getTargetKeyUpHandler = function (handleQueryListKeyUp) {
            return function (evt) {
                var _a = _this.props.inputProps, inputProps = _a === void 0 ? {} : _a;
                if (_this.state.isOpen) {
                    Utils.safeInvoke(handleQueryListKeyUp, evt);
                }
                Utils.safeInvoke(inputProps.onKeyUp, evt);
            };
        };
        return _this;
    }
    Suggest.ofType = function () {
        return Suggest;
    };
    Suggest.prototype.render = function () {
        // omit props specific to this component, spread the rest.
        var _a = this.props, inputProps = _a.inputProps, popoverProps = _a.popoverProps, restProps = tslib_1.__rest(_a, ["inputProps", "popoverProps"]);
        return (React.createElement(this.TypedQueryList, tslib_1.__assign({}, restProps, { activeItem: this.state.activeItem, onActiveItemChange: this.handleActiveItemChange, onItemSelect: this.handleItemSelect, query: this.state.query, ref: this.refHandlers.queryList, renderer: this.renderQueryList })));
    };
    Suggest.prototype.componentDidUpdate = function (_prevProps, prevState) {
        if (this.state.isOpen && !prevState.isOpen && this.queryList != null) {
            this.queryList.scrollActiveItemIntoView();
        }
    };
    Suggest.displayName = "Blueprint2.Suggest";
    // Note: can't use <T> in static members, so this remains dynamically typed.
    Suggest.defaultProps = {
        closeOnSelect: true,
        openOnKeyDown: false,
    };
    return Suggest;
}(React.PureComponent));
export { Suggest };
