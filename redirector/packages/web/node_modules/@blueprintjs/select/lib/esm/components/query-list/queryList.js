/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the terms of the LICENSE file distributed with this project.
 */
import * as tslib_1 from "tslib";
import * as React from "react";
import { Keys, Menu, Utils } from "@blueprintjs/core";
import { renderFilteredItems } from "../../common";
var QueryList = /** @class */ (function (_super) {
    tslib_1.__extends(QueryList, _super);
    function QueryList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.refHandlers = {
            itemsParent: function (ref) { return (_this.itemsParentRef = ref); },
        };
        /**
         * flag indicating that we should check whether selected item is in viewport after rendering,
         * typically because of keyboard change.
         */
        _this.shouldCheckActiveItemInViewport = false;
        /** default `itemListRenderer` implementation */
        _this.renderItemList = function (listProps) {
            var _a = _this.props, initialContent = _a.initialContent, noResults = _a.noResults;
            var menuContent = renderFilteredItems(listProps, noResults, initialContent);
            return React.createElement(Menu, { ulRef: listProps.itemsParentRef }, menuContent);
        };
        /** wrapper around `itemRenderer` to inject props */
        _this.renderItem = function (item, index) {
            var _a = _this.props, activeItem = _a.activeItem, query = _a.query;
            var matchesPredicate = _this.state.filteredItems.indexOf(item) >= 0;
            var modifiers = {
                active: activeItem === item,
                disabled: false,
                matchesPredicate: matchesPredicate,
            };
            return _this.props.itemRenderer(item, {
                handleClick: function (e) { return _this.handleItemSelect(item, e); },
                index: index,
                modifiers: modifiers,
                query: query,
            });
        };
        _this.handleItemSelect = function (item, event) {
            Utils.safeInvoke(_this.props.onActiveItemChange, item);
            Utils.safeInvoke(_this.props.onItemSelect, item, event);
        };
        _this.handleKeyDown = function (event) {
            switch (event.keyCode) {
                case Keys.ARROW_UP:
                    event.preventDefault();
                    _this.moveActiveIndex(-1);
                    break;
                case Keys.ARROW_DOWN:
                    event.preventDefault();
                    _this.moveActiveIndex(1);
                    break;
                default:
                    break;
            }
            Utils.safeInvoke(_this.props.onKeyDown, event);
        };
        _this.handleKeyUp = function (event) {
            var _a = _this.props, activeItem = _a.activeItem, onItemSelect = _a.onItemSelect, onKeyUp = _a.onKeyUp;
            // using keyup for enter to play nice with Button's keyboard clicking.
            // if we were to process enter on keydown, then Button would click itself on keyup
            // and the popvoer would re-open out of our control :(.
            if (event.keyCode === Keys.ENTER && activeItem != null) {
                event.preventDefault();
                Utils.safeInvoke(onItemSelect, activeItem, event);
            }
            Utils.safeInvoke(onKeyUp, event);
        };
        return _this;
    }
    QueryList.ofType = function () {
        return QueryList;
    };
    QueryList.prototype.render = function () {
        var _a = this.props, className = _a.className, items = _a.items, renderer = _a.renderer, query = _a.query, _b = _a.itemListRenderer, itemListRenderer = _b === void 0 ? this.renderItemList : _b;
        var filteredItems = this.state.filteredItems;
        return renderer({
            className: className,
            filteredItems: filteredItems,
            handleItemSelect: this.handleItemSelect,
            handleKeyDown: this.handleKeyDown,
            handleKeyUp: this.handleKeyUp,
            itemList: itemListRenderer({
                filteredItems: filteredItems,
                items: items,
                itemsParentRef: this.refHandlers.itemsParent,
                query: query,
                renderItem: this.renderItem,
            }),
            query: query,
        });
    };
    QueryList.prototype.componentWillMount = function () {
        this.setState({ filteredItems: getFilteredItems(this.props) });
    };
    QueryList.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.items !== this.props.items ||
            nextProps.itemListPredicate !== this.props.itemListPredicate ||
            nextProps.itemPredicate !== this.props.itemPredicate ||
            nextProps.query !== this.props.query) {
            this.shouldCheckActiveItemInViewport = true;
            this.setState({ filteredItems: getFilteredItems(nextProps) });
        }
    };
    QueryList.prototype.componentDidUpdate = function () {
        var _this = this;
        if (this.shouldCheckActiveItemInViewport) {
            // update scroll position immediately before repaint so DOM is accurate
            // (latest filteredItems) and to avoid flicker.
            requestAnimationFrame(function () { return _this.scrollActiveItemIntoView(); });
            // reset the flag
            this.shouldCheckActiveItemInViewport = false;
        }
        // reset active item (in the same step) if it's no longer valid
        // Also don't fire the event if the active item is already undefined and there is nothing to pick
        if (this.getActiveIndex() < 0 &&
            (this.state.filteredItems.length !== 0 || this.props.activeItem !== undefined)) {
            Utils.safeInvoke(this.props.onActiveItemChange, this.state.filteredItems[0]);
        }
    };
    QueryList.prototype.scrollActiveItemIntoView = function () {
        var activeElement = this.getActiveElement();
        if (this.itemsParentRef != null && activeElement != null) {
            var activeTop = activeElement.offsetTop, activeHeight = activeElement.offsetHeight;
            var _a = this.itemsParentRef, parentOffsetTop = _a.offsetTop, parentScrollTop = _a.scrollTop, parentHeight = _a.clientHeight;
            // compute padding on parent element to ensure we always leave space
            var _b = this.getItemsParentPadding(), paddingTop = _b.paddingTop, paddingBottom = _b.paddingBottom;
            // compute the two edges of the active item for comparison, including parent padding
            var activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;
            var activeTopEdge = activeTop - paddingTop - parentOffsetTop;
            if (activeBottomEdge >= parentScrollTop + parentHeight) {
                // offscreen bottom: align bottom of item with bottom of viewport
                this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;
            }
            else if (activeTopEdge <= parentScrollTop) {
                // offscreen top: align top of item with top of viewport
                this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;
            }
        }
    };
    QueryList.prototype.getActiveElement = function () {
        if (this.itemsParentRef != null) {
            return this.itemsParentRef.children.item(this.getActiveIndex());
        }
        return undefined;
    };
    QueryList.prototype.getActiveIndex = function () {
        var activeItem = this.props.activeItem;
        // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.
        return activeItem == null ? -1 : this.state.filteredItems.indexOf(activeItem);
    };
    QueryList.prototype.getItemsParentPadding = function () {
        // assert ref exists because it was checked before calling
        var _a = getComputedStyle(this.itemsParentRef), paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;
        return {
            paddingBottom: pxToNumber(paddingBottom),
            paddingTop: pxToNumber(paddingTop),
        };
    };
    QueryList.prototype.moveActiveIndex = function (direction) {
        // indicate that the active item may need to be scrolled into view after update.
        // this is not possible with mouse hover cuz you can't hover on something off screen.
        this.shouldCheckActiveItemInViewport = true;
        var filteredItems = this.state.filteredItems;
        var maxIndex = Math.max(filteredItems.length - 1, 0);
        var nextActiveIndex = Utils.clamp(this.getActiveIndex() + direction, 0, maxIndex);
        Utils.safeInvoke(this.props.onActiveItemChange, filteredItems[nextActiveIndex]);
    };
    QueryList.displayName = "Blueprint2.QueryList";
    return QueryList;
}(React.Component));
export { QueryList };
function pxToNumber(value) {
    return value == null ? 0 : parseInt(value.slice(0, -2), 10);
}
function getFilteredItems(_a) {
    var items = _a.items, itemPredicate = _a.itemPredicate, itemListPredicate = _a.itemListPredicate, query = _a.query;
    if (Utils.isFunction(itemListPredicate)) {
        // note that implementations can reorder the items here
        return itemListPredicate(query, items);
    }
    else if (Utils.isFunction(itemPredicate)) {
        return items.filter(function (item, index) { return itemPredicate(query, item, index); });
    }
    return items;
}
